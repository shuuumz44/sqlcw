database info struct:

- table count
- table names

** info about all tables within a database can be collected by executing a regular SQL statement, specifically on the "sqlite_master" table.

specific command to retrieve table count in a database: SELECT COUNT(*) FROM sqlite_master WHERE type = 'table' AND name NOT IN ('android_metadata', 'sqlite_sequence');
"NOT IN" clauses included to remove pesky automatically generated files. 
---------------------
    - for each table:
        - column count
        - column names

 ^^^ IMPLEMENTATION NOTES ^^^
    SQL is not very friendly towards output control. There exist specific functions to retrieve certain data, and the way that results are
    printed can be modified, however SQL strictly prints output, instead of returning output.
    This means that in order to direct whatever SQL outputs into data that we can cache, we have to get a little more creative.

    Initially caching all of the data on a database like this will require that we take all of sqlite's outputs, output them in a specific way
    most readable for our needs, and scan the output somewhere else for further parsing.

    for example, we can prompt sqlite for all the information about a table in a database, specify the .mode to output as JSON, and pipe that output to
    a JSON parser so that we can cache all of THAT data into our database struct, for further sqlite prompting.
    ~ at least that's the plan for now. ~

    ^^^ BUILDING JSON OBJECT (object does not exist) :
        table_count:    SELECT COUNT(*) FROM sqlite_master;
        table_names:    for (int i=0; i < table_count; i++) {   SELECT tbl_name FROM sqlite_master WHERE [row_id] = i;  }
                        * figure out which built-in value "row_id" was.
        column_count:   

    ^^^ READING JSON OBJECT (object already exists) :
        1. convert entire JSON file into a string.
        2. parse string into json_object with json.h library.

        --- as of right now: make makefile properly find header files in ./header directory
        *** you need to include all the *.c files as well...

wrapper implementation:
    Usage: wrapper.exe [OPTION] DATABASE.db [TABLE]

    Options:
        -c  add a row into the selected table.
        -r  select data from the selected table.
        -u  update data from the selected table.
        -d  delete data from the selected table.
        *options will fail if a table is unspecified.

        -h  list options.

    Invocations:
        Naked:
            - list database info struct, and options (CRUD).
            
            - upon invocation, script caches relevant information about the database into a struct.
            (should this be an actual created file to cover for multiple invocations?? I think so. Should I look into JSON or yaml now? Possibly.)

            - retrieve database table count, and all table names in the database, cached into an array.
            
            - print the table names and corresponding array index.

        Table specified:
            - perform specified action on given table, otherwise list CRUD options.

    Execution:
        - Check if invocation is properly formatted, and that database exists.

        - Check to see if .JSON file exists.
            --  if .JSON does not exist, create it:
                # extract all existing tables from sqlite_master table.
                # for each table, extract column count and column names.
                    --- extracting data from SQLite ---
                    *Since SQLite is entirely print-based for all relevant purposes, direct output to a (JSON) file and read with file I/O functions.
                    @ output entry to file
                    @ use json-parser dependency to read file / cache values into database struct

        - Execute statement in accordance with invocation rules.

***further add-ons:
    - regular SQL statement execution flag. ignores wrapper abstraction and just executes the statement as normal SQL if need be
    - CMake dependency initializer. What this means is just that at the start of attempting to make a wrapper, I had to configure the sqlite3 library
    header files in order to use the associated sqlite3 objects, functions and so on. Which meant downloading a .tar file,
    figuring out which files to move to my directory, and figuring out what flags to use during compilation.
    Make a script to retrieve all the necessary files automatically. 
    (*I think this is what CMake is used for.)  